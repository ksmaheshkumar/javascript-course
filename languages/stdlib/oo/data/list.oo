module

  let Maybe = require("std:data/maybe")

  let List = ffi "$List"
  let Nil  = List.Nil
  let Cons = List.Cons

  // ^-- the definition of the following sum type:
  //
  // data List = Nil
  //           | Cons(head, tail)
  // end
  //
  // ^--

  // -- Semigroup
  method List#concat(self, ys) = match self with
    | Nil         => ys
    | Cons(x, xs) => Cons(x, xs ++ ys)
  end
  
  // -- Monoid 
  method List#empty(self) = Nil

  // -- Functor
  method List#map(self, f) = match self with
    | Nil         => Nil
    | Cons(x, xs) => Cons(f(x), xs#map(f))
  end

  // -- Apply
  method List#ap(self, bs) = bs#map(b -> self#map(f -> f(b)))

  // -- Applicative
  method List#of(_, a) = Cons(a, Nil)

  // -- Chain / Monad
  method List#chain(self, f) = match self with
    | Nil         => Nil
    | Cons(x, xs) => f(x) ++ xs#chain(f)
  end

  // Returns the first item of the list.
  // head :: List<a> → Maybe<a>
  let first = xs -> match xs with
    | Nil        => Maybe.Nothing
    | Cons(a, _) => Maybe.Just(a)
  end

  // Returns the rest of the list.
  // rest :: List<a> → List<a>
  let rest = xs -> match xs with
    | Nil           => Nil
    | Cons(_, tail) => tail
  end

  // Filters items of a list.
  // filter :: (a → Boolean) → List<a> → List<a>
  let filter = (f, xs) -> match xs with
    | Nil         => Nil
    | Cons(x, ys) => f(x)?  Cons(x, filter(f, ys))
                         :  filter(f, ys)
  end

  // Takes the last item of a list.
  // last :: List<a> → Maybe<a>
  let last = xs -> match xs with
    | Nil         => Nothing
    | Cons(x, ys) => isEmpty(ys)?  Just(x)
                                :  last(ys)
  end

  // Checks if a list is empty.
  // isEmpty :: List<a> → Boolean
  let isEmpty = xs -> xs === Nil

  let at = (n, xs) -> match xs with
    | Nil         => Nil
    | Cons(x, ys) => n === 0?  x
                            :  at(n - 1, ys)
  end

  let foldl = (f, b, xs) -> ffi "(function $recur(z, xs) {
    if (xs === Nil) return z
    if (xs instanceof Cons) {
      return $recur(f(z)(xs.head), xs.tail)
    }
    throw new Error('No cases matched the value ' + xs)
  })(b, xs)
  "

  let foldr = (f, b, xs) -> match xs with
    | Nil         => b
    | Cons(x, ys) => f(x, foldr(f, b, ys))
  end

  let reverse = foldl((xs, x) -> Cons(x, xs))(Nil)

  let length = foldl((n, _) -> n + 1)(0)

  let any = (f, xs) -> match xs with
    | Nil         => true
    | Cons(x, ys) => f(x)?  true
                         :  any(ys)
  end

  let all = (f, xs) -> match xs with
    | Nil         => false
    | Cons(x, ys) => f(x)?  all(ys)
                         :  false
  end

  let sum = foldl((x, y) -> x + y)(0)

  

  export List, Nil, Cons, first, rest, filter, last, isEmpty, length, at
       , reverse, foldl, foldr

end
